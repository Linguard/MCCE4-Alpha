#!/usr/bin/env python3

"""
Created on Thu Aug 14 3:30:00 2025

@author: Gehan Ranepura
"""
import argparse
from datetime import datetime
import os
from pathlib import Path
import shlex
from subprocess import Popen, PIPE, run, STDOUT, CalledProcessError
import sys


def run_command(cmd: str, label: str, logfile: str = None):
    """
    Run a command with real-time 'tee'-style logging:
      - Streams stdout/stderr to the console
      - Also writes them to logfile (if provided), with timestamps
    Accepts either a list argv (preferred) or a string (shell=True).
    """
    print(f"\nRunning {label}:")
    is_list = isinstance(cmd, list)
    pretty = shlex.join(cmd) if is_list else cmd
    print("  " + pretty + (f"  >> {logfile}" if logfile else ""))

    fh = open(logfile, "a") if logfile else None
    try:
        if fh:
            fh.write(f"=== {label} started {datetime.now().isoformat()} ===\n")

        if is_list:
            proc = Popen(cmd, stdout=PIPE, stderr=STDOUT, text=True, bufsize=1)
        else:
            proc = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT, text=True, bufsize=1)

        for line in proc.stdout:
            print(line, end="")
            if fh:
                fh.write(line)
        proc.stdout.close()
        ret = proc.wait()
        if ret != 0:
            raise CalledProcessError(ret, pretty)

        print(f"{label} completed.")
        if fh:
            fh.write(f"=== {label} completed {datetime.now().isoformat()} ===\n")

    except CalledProcessError:
        print(f"Error: {label} failed.")
        if fh:
            fh.write(f"=== {label} FAILED {datetime.now().isoformat()} ===\n")
        sys.exit(1)

    finally:
        if fh:
            fh.flush()
            fh.close()
    
    return


def ensure_prot_pdb(input_pdb: str):
    # Link input_pdb to prot.pdb so downstream scripts see the expected file
    pdb_fp = Path(input_pdb)
    if pdb_fp.name != "prot.pdb":
        # Create a symbolic link to "prot.pdb"
        prot_fp = pdb_fp.with_name("prot.pdb")
        if prot_fp.exists():
            if not prot_fp.is_symlink():
                # remove hard copy first
                prot_fp.unlink()
                prot_fp.symlink_to(pdb_fp.name)
            else:
                return
        else:
            prot_fp.symlink_to(pdb_fp.name)

    return


def logpath(logs_dir: str, filename: str) -> str:
    return os.path.join(logs_dir, filename)

# ---------------------------
# Legacy Default MCCE4 Simulation
# ---------------------------
def run_legacy_pipeline(input_pdb: str, logs_dir: str):
    ensure_prot_pdb(input_pdb)

    STEP1 = "step1.py prot.pdb -d 4 --dry"
    STEP2 = "step2.py -l 1 -d 4"
    STEP3 = "step3.py -s ngpb -d 4"
    STEP4 = "step4.py --xts"

    run_command(STEP1, "STEP1", logfile=logpath(logs_dir, "step1.log"))
    run_command(STEP2, "STEP2", logfile=logpath(logs_dir, "step2.log"))
    run_command(STEP3, "STEP3", logfile=logpath(logs_dir, "step3.log"))
    run_command(STEP4, "STEP4", logfile=logpath(logs_dir, "step4.log"))

    return

# ---------------------------
# Flag-driven pipeline
# ---------------------------
def run_param_pipeline(args: argparse.Namespace, logs_dir: str):
    input_pdb = args.pdb
    ensure_prot_pdb(input_pdb)

    dielectric = args.d if args.d is not None else 4

    print("\n[Pipeline Parameters]")
    print(f"  Dielectric (Steps 1–3): {dielectric}")
    print(f"  Step1 hydration: {'WET (no --dry)' if args.wet else 'DRY (--dry)'}")
    print(f"  Step2 conformer level (-l): {args.l}")
    print(f"  Step3 solver (-s): {args.s}")
    print(f"  Step3 --fly: {'ON' if args.fly else 'OFF'}")
    print(f"  Step3 FTPL (-ftpl): {args.ftpl if args.ftpl else 'default'}")
    print(f"  Step3 salt (-salt): {args.salt if args.salt is not None else 0.15}")
    print(f"  Step3 flags: skip_pb={args.skip_pb}, old_vdw={args.old_vdw}, "
          f"vdw_relax={args.vdw_relax if args.vdw_relax is not None else 0}, "
          f"refresh={args.refresh}, debug={args.debug}")
    print(f"  Step3 CPUs (-p): {args.p if args.p is not None else 'default'}")
    print(f"  Step3 tmp dir (-tmp): {args.tmp if args.tmp is not None else 'default'}")
    print(f"  Step4 titration: type={args.type or 'ph'}, init={args.initial if args.initial is not None else 0.0}, "
          f"interval={args.interval if args.interval is not None else 1.0}, "
          f"steps={args.n if args.n is not None else 15}, ms={'ON' if args.ms else 'OFF'}")
    print(f"  Logs dir: {logs_dir}\n")

    # ---- STEP 1
    step1 = ["step1.py", "prot.pdb", "-d", str(dielectric)]
    if not args.wet:
        step1.append("--dry")

    # ---- STEP 2
    step2 = ["step2.py", "-d", str(dielectric), "-l", str(args.l)]

    # ---- STEP 3 (map -tmp -> underlying -t)
    step3 = ["step3.py", "-d", str(dielectric)]
    if args.s:
        step3 += ["-s", args.s]
    if args.fly:
        step3 += ["--fly"]
    if args.ftpl:
        step3 += ["-ftpl", args.ftpl]
    if args.salt is not None:
        step3 += ["-salt", str(args.salt)]
    if args.skip_pb:
        step3 += ["--skip_pb"]
    if args.old_vdw:
        step3 += ["--old_vdw"]
    if args.vdw_relax is not None:
        step3 += ["-vdw_relax", str(args.vdw_relax)]
    if args.refresh:
        step3 += ["--refresh"]
    if args.debug:
        step3 += ["--debug"]
    if args.p is not None:
        step3 += ["-p", str(args.p)]
    if args.tmp is not None:
        step3 += ["-t", args.tmp]   # underlying step3.py expects -t

    # ---- STEP 4 (map wrapper flags to underlying -t/-i/-d/-n/--ms)
    step4 = ["step4.py", "--xts"]
    if args.type:
        step4 += ["-t", args.type]
    if args.initial is not None:
        step4 += ["-i", str(args.initial)]
    if args.interval is not None:
        step4 += ["-d", str(args.interval)]
    if args.n is not None:
        step4 += ["-n", str(args.n)]
    if args.ms:
        step4 += ["--ms"]

    run_command(step1, "STEP1", logfile=logpath(logs_dir, "step1.log"))
    run_command(step2, "STEP2", logfile=logpath(logs_dir, "step2.log"))
    run_command(step3, "STEP3", logfile=logpath(logs_dir, "step3.log"))
    run_command(step4, "STEP4", logfile=logpath(logs_dir, "step4.log"))

    return


# ---------- CLI utilities ----------
def was_passed(*names):
    """
    Returns True if any of the provided CLI flag names appear in sys.argv.
    Handles separated (-d 4) and concatenated single-char opts (-d4).
    """
    argv = sys.argv[1:]  # ignore program name
    for a in argv:
        for name in names:
            if a == name:
                return True
            # handle concatenated single-char options, e.g., -d6
            if name.startswith("-") and not name.startswith("--"):
                if len(name) == 2 and a.startswith(name) and a != name:
                    return True
    return False


def any_pipeline_flags_passed():
    # If any of these appear, we switch to the param pipeline
    return (
        was_passed("-d", "--wet", "-l", "-s", "-p", "-tmp", "--fly") or
        was_passed("-ftpl", "-salt", "--skip_pb", "--old_vdw",
                   "-vdw_relax", "--refresh", "--debug") or
        was_passed("-type", "-initial", "-interval", "-n", "--ms")
    )


def any_non_custom_flags_passed_with_custom():
    """
    Return True if --custom is combined with any disallowed flags.
    Allowed with --custom: ONLY the positional PDB and optional --sbatch.
    """
    return any_pipeline_flags_passed()


def run_custom_script(script, input_pdb, use_sbatch):
    ensure_prot_pdb(input_pdb)

    if not os.path.isfile(script):
        print(f"Error: Custom script '{script}' not found.")
        sys.exit(1)

    if use_sbatch:
        # Non-blocking submission; show job id
        print("\nSubmitting custom script via SLURM (non-blocking)...")
        res = run(
            ["sbatch", script],
            check=True,
            stdout=PIPE,
            stderr=STDOUT,
            text=True
        )
        print(res.stdout.strip())
        print("CLI returned immediately after sbatch submission.")
    else:
        print("\nRunning custom script via shell...")
        run_command(["bash", script], "Custom script")

    return


def main():
    parser = argparse.ArgumentParser(
        description="""
Run MCCE4 either via the legacy default 4-step pipeline (no flags),
a flag-driven pipeline (if flags are provided), or with a custom SLURM shell script.

Rules:
- --custom may only be combined with the positional PDB and optional --sbatch.
- --sbatch can only be used together with --custom.
- If any other flags are present with --custom, the command will error.

Examples:
  # Legacy default MCCE4 simulation:
  run_mcce4 myprotein.pdb

  # Flag-driven:
  run_mcce4 myprotein.pdb -d 6 --wet
  run_mcce4 myprotein.pdb -d 6 -l 2 -s delphi -p 5 -tmp scrap --fly -salt 0.2 -type ph -initial 0 -interval 1 -n 15

  # Custom script:
  run_mcce4 myprotein.pdb --custom submit_mcce4.sh
  run_mcce4 myprotein.pdb --custom submit_mcce4.sh --sbatch
        """,
        formatter_class=argparse.RawTextHelpFormatter
    )

    # Positional & custom-script options
    parser.add_argument("pdb",      help="Input PDB file (linked to 'prot.pdb')")
    parser.add_argument("--custom", help="Optional shell script to run instead of default/flag pipelines")
    parser.add_argument("--sbatch", action="store_true", help="Use sbatch to submit the custom shell script (non-blocking)")

    # ---- Flag-driven pipeline options

    # Global / Step 1–3
    parser.add_argument("-d",    type=int, metavar="epsilon", help="Global inner dielectric for Steps 1–3 (default: 4)")
    parser.add_argument("--wet", action="store_true", help="Step1: run WET (omit --dry) (default is DRY)")

    # Step 2
    parser.add_argument("-l",    type=int, metavar="level", default=1, help="Step2: conformer level (default: 1)")

    # Step 3 (your preferred names)
    parser.add_argument("-s",    type=str, metavar="solver", default="ngpb", help="Step3: PBE solver (default: ngpb)")
    parser.add_argument("-p",    type=int, metavar="processes",  help="Step3: Number of CPUs to use")
    parser.add_argument("-tmp",  type=str, metavar="tmp_folder", help="Step3: Temporary PBE data directory")
    parser.add_argument("-ftpl", dest="ftpl", type=str, metavar="ftpl_folder", help="Step3: ftpl folder; default is 'param/' next to mcce executable.")
    parser.add_argument("-salt", dest="salt", type=float, metavar="salt_concentration", help="Step3: salt concentration in mol/L (default: 0.15).")
    parser.add_argument("-vdw_relax", dest="vdw_relax", type=float, metavar="vdw_R_relaxation", help="Step3: relax vdw R by ±value (default: 0).")
    parser.add_argument("--fly",     action="store_true",  help="Step3: do-the-fly rxn0 calculation")
    parser.add_argument("--skip_pb", action="store_true", help="Step3: run vdw/torsion only; skip PB.")
    parser.add_argument("--old_vdw", action="store_true", help="Step3: use old vdw function calculations.")
    parser.add_argument("--refresh", action="store_true", help="Step3: recreate *.opp and head3.lst from step2_out.pdb and *.raw.")
    parser.add_argument("--debug",   action="store_true", help="Step3: print debug info and keep PB solver tmp.")

    # Step 4 (your preferred names; mapped to underlying -t/-i/-d/-n/--ms)
    parser.add_argument("-type", choices=["ph", "eh"], help="Step4: titration type (maps to '-t'). Default: ph")
    parser.add_argument("-initial",  type=float, metavar="initial ph/eh", help="Step4: initial pH/Eh (maps to '-i'). Default: 0.0")
    parser.add_argument("-interval", type=float, metavar="interval",      help="Step4: titration interval pH or mV (maps to '-d'). Default: 1.0")
    parser.add_argument("-n",        type=int,   metavar="steps",         help="Step4: number of titration steps (maps to '-n'). Default: 15")
    parser.add_argument("--ms",      action="store_true", help="Step4: enable microstate output (maps to '--ms').")

    args = parser.parse_args()

    if not os.path.isfile(args.pdb):
        print(f"Error: PDB file '{args.pdb}' not found.")
        sys.exit(1)

    # Prepare logs directory (always './logs')
    logs_dir = os.path.abspath("logs")
    os.makedirs(logs_dir, exist_ok=True)

    # Normalize some paths
    if args.tmp:
        args.tmp = os.path.expanduser(args.tmp)
    if args.ftpl:
        args.ftpl = os.path.expanduser(args.ftpl)

    # --- Enforce CLI rules ---

    # 1) --sbatch must only be used with --custom
    if args.sbatch and not args.custom:
        parser.error("--sbatch can only be used together with --custom.")

    # 2) --custom may only be combined with positional PDB and optional --sbatch
    if args.custom and any_non_custom_flags_passed_with_custom():
        parser.error("--custom may only be combined with the positional PDB and optional --sbatch (no other flags allowed).")

    # --- Route execution ---

    if args.custom:
        run_custom_script(args.custom, args.pdb, args.sbatch)
        return

    # If any pipeline flags were passed, use param pipeline; else legacy default
    if any_pipeline_flags_passed():
        run_param_pipeline(args, logs_dir)
    else:
        run_legacy_pipeline(args.pdb, logs_dir)

    return


if __name__ == "__main__":
    main()
